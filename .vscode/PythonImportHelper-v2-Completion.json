[
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "dns_query",
        "importPath": "recursive_dns",
        "description": "recursive_dns",
        "isExtraImport": true,
        "detail": "recursive_dns",
        "documentation": {}
    },
    {
        "label": "dns_query",
        "importPath": "recursive_dns",
        "description": "recursive_dns",
        "isExtraImport": true,
        "detail": "recursive_dns",
        "documentation": {}
    },
    {
        "label": "iterative_dns_query",
        "importPath": "iterative_dns",
        "description": "iterative_dns",
        "isExtraImport": true,
        "detail": "iterative_dns",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "SimBuffer",
        "importPath": "Classes",
        "description": "Classes",
        "isExtraImport": true,
        "detail": "Classes",
        "documentation": {}
    },
    {
        "label": "NetworkTrace",
        "importPath": "Classes",
        "description": "Classes",
        "isExtraImport": true,
        "detail": "Classes",
        "documentation": {}
    },
    {
        "label": "Scorecard",
        "importPath": "Classes",
        "description": "Classes",
        "isExtraImport": true,
        "detail": "Classes",
        "documentation": {}
    },
    {
        "label": "simulator_comm",
        "importPath": "Classes",
        "description": "Classes",
        "isExtraImport": true,
        "detail": "Classes",
        "documentation": {}
    },
    {
        "label": "studentcode_122090513",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "studentcode_122090513",
        "description": "studentcode_122090513",
        "detail": "studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "parse_domain_name",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def parse_domain_name(data, offset):\n    \"\"\"\n    Parse a domain name from the DNS response, handling DNS name compression.\n    Args:\n        data (bytes): The DNS response data.\n        offset (int): The current offset in the response.\n    Returns:\n        tuple: (domain_name, new_offset)\n    \"\"\"\n    labels = []",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "iterative_dns_query",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def iterative_dns_query(domain_name, query_type, transaction_id):\n    \"\"\"\n    Perform iterative DNS query by querying the root DNS servers and following referrals.\n    Args:\n        domain_name (str): The domain name to resolve.\n        query_type (int): The DNS query type.\n        transaction_id (int): The transaction ID for the DNS request.\n    Returns:\n        bytes: The DNS response data from the final authoritative server.\n    \"\"\"",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "parse_ns_record",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def parse_ns_record(rdata):\n    \"\"\"\n    Parse the NS record from rdata.\n    Args:\n        rdata (bytes): The raw rdata containing the NS record.\n    Returns:\n        str: The domain name of the NS record.\n    \"\"\"\n    return parse_domain_name(rdata, 0)[0]\ndef resolve_ns_to_ip(ns_domain_name):",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "resolve_ns_to_ip",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def resolve_ns_to_ip(ns_domain_name):\n    \"\"\"\n    Resolve the IP address of a given NS record using a public DNS server (like 8.8.8.8).\n    Args:\n        ns_domain_name (str): The domain name of the NS record.\n    Returns:\n        str: The resolved IP address of the NS record, or None if resolution fails.\n    \"\"\"\n    try:\n        logger.info(f\"Resolving IP for NS domain: {ns_domain_name}\")",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "parse_dns_response",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def parse_dns_response(response):\n    \"\"\"\n    Parse the DNS response and extract all useful information, including header, question, answer, authority, \n    and additional sections.\n    Args:\n        response (bytes): The raw DNS response.\n    Returns:\n        dict: Parsed DNS response with relevant sections.\n    \"\"\"\n    parsed_data = {",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "get_next_server_ip",
        "kind": 2,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "def get_next_server_ip(parsed_data):\n    \"\"\"\n    Extract the next DNS server IP from the Additional section of the parsed DNS response.\n    Args:\n        parsed_data (dict): Parsed DNS response data.\n    Returns:\n        str: The next DNS server IP if found, else None.\n    \"\"\"\n    for record in parsed_data['additional']:\n        if record['rtype'] == 1:  # A record (IPv4)",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "ROOT_SERVERS",
        "kind": 5,
        "importPath": "HW1.iterative_dns",
        "description": "HW1.iterative_dns",
        "peekOfCode": "ROOT_SERVERS = [\n    \"198.41.0.4\",  # a.root-servers.net\n    \"199.9.14.201\",  # b.root-servers.net\n    \"192.33.4.12\",  # c.root-servers.net\n]\ndef parse_domain_name(data, offset):\n    \"\"\"\n    Parse a domain name from the DNS response, handling DNS name compression.\n    Args:\n        data (bytes): The DNS response data.",
        "detail": "HW1.iterative_dns",
        "documentation": {}
    },
    {
        "label": "resolve_dns_query",
        "kind": 2,
        "importPath": "HW1.main",
        "description": "HW1.main",
        "peekOfCode": "def resolve_dns_query(domain_name, query_type, transaction_id, iterative):\n    \"\"\"\n    Resolve DNS query either iteratively or by forwarding to a public DNS server.\n    Args:\n        domain_name (str): The domain name to resolve.\n        query_type (int): The DNS query type.\n        transaction_id (int): The transaction ID for the DNS request.\n        iterative (bool): Whether to use iterative DNS resolution.\n    Returns:\n        bytes: The DNS response data.",
        "detail": "HW1.main",
        "documentation": {}
    },
    {
        "label": "modify_transaction_id",
        "kind": 2,
        "importPath": "HW1.main",
        "description": "HW1.main",
        "peekOfCode": "def modify_transaction_id(response, new_transaction_id):\n    \"\"\"\n    Modify the transaction ID of a DNS response to match the new query's transaction ID.\n    Args:\n        response (bytes): The original DNS response packet.\n        new_transaction_id (int): The new transaction ID from the current query.\n    Returns:\n        bytes: The modified DNS response packet with the new transaction ID.\n    \"\"\"\n    return struct.pack('!H', new_transaction_id) + response[2:]",
        "detail": "HW1.main",
        "documentation": {}
    },
    {
        "label": "start_dns_server",
        "kind": 2,
        "importPath": "HW1.main",
        "description": "HW1.main",
        "peekOfCode": "def start_dns_server(server_ip, port, iterative):\n    \"\"\"\n    Start the local DNS server to listen for incoming DNS queries and respond accordingly.\n    Args:\n        server_ip (str): The IP address for the local DNS server.\n        port (int): The port for the local DNS server.\n        iterative (bool): Whether to perform iterative DNS resolution.\n    \"\"\"\n    cache = {}\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)",
        "detail": "HW1.main",
        "documentation": {}
    },
    {
        "label": "parse_dns_query",
        "kind": 2,
        "importPath": "HW1.main",
        "description": "HW1.main",
        "peekOfCode": "def parse_dns_query(data):\n    \"\"\"\n    Parse the incoming DNS query and extract the transaction ID, domain name, and query type.\n    Args:\n        data (bytes): The raw DNS query data.\n    Returns:\n        tuple: (transaction_id, domain_name, query_type)\n    \"\"\"\n    transaction_id = struct.unpack('!H', data[:2])[0]\n    domain_name = ''",
        "detail": "HW1.main",
        "documentation": {}
    },
    {
        "label": "build_dns_query",
        "kind": 2,
        "importPath": "HW1.recursive_dns",
        "description": "HW1.recursive_dns",
        "peekOfCode": "def build_dns_query(domain_name, query_type, transaction_id):\n    \"\"\"\n    Build the DNS query packet based on the domain name, query type, and transaction ID.\n    Args:\n        domain_name (str): The domain name to resolve.\n        query_type (int): The type of DNS query (e.g., A, AAAA).\n        transaction_id (int): The transaction ID for the DNS request.\n    Returns:\n        bytes: The DNS query packet to send to the DNS server.\n    \"\"\"",
        "detail": "HW1.recursive_dns",
        "documentation": {}
    },
    {
        "label": "dns_query",
        "kind": 2,
        "importPath": "HW1.recursive_dns",
        "description": "HW1.recursive_dns",
        "peekOfCode": "def dns_query(domain_name, query_type, dns_server, transaction_id, timeout=2):\n    \"\"\"\n    Perform a DNS query to a specified DNS server with a timeout mechanism.\n    Args:\n        domain_name (str): The domain name to resolve.\n        query_type (int): The DNS query type.\n        dns_server (str): The DNS server IP to query.\n        transaction_id (int): The transaction ID for the DNS request.\n        timeout (int): The timeout in seconds for the socket operation (default 2 seconds).\n    Returns:",
        "detail": "HW1.recursive_dns",
        "documentation": {}
    },
    {
        "label": "is_answer",
        "kind": 2,
        "importPath": "HW1.recursive_dns",
        "description": "HW1.recursive_dns",
        "peekOfCode": "def is_answer(response):\n    \"\"\"\n    Check if the DNS response contains an answer.\n    Args:\n        response (bytes): The DNS response.\n    Returns:\n        bool: True if the response contains an answer, False otherwise.\n    \"\"\"\n    flags = struct.unpack('!H', response[2:4])[0]\n    answer_count = struct.unpack('!H', response[6:8])[0]",
        "detail": "HW1.recursive_dns",
        "documentation": {}
    },
    {
        "label": "NetworkTrace",
        "kind": 6,
        "importPath": "HW2.Classes.NetworkTrace",
        "description": "HW2.Classes.NetworkTrace",
        "peekOfCode": "class NetworkTrace:\n    def __init__(self, bandwidths):\n        self.bwlist = bandwidths\n    #returns the timesegment the time argument is within\n    def get_current_timesegment(self, cur_time):\n        return min(self.bwlist, key= lambda x: abs(x[0] - cur_time) if cur_time > x[0] else math.inf )\n    def simulate_download_from_time(self, time, size):\n        cum_time = 0\n        timeseg = self.get_current_timesegment(time)\n        while(1):",
        "detail": "HW2.Classes.NetworkTrace",
        "documentation": {}
    },
    {
        "label": "Scorecard",
        "kind": 6,
        "importPath": "HW2.Classes.Scorecard",
        "description": "HW2.Classes.Scorecard",
        "peekOfCode": "class Scorecard:\n    def __init__(self, qual_coef, buf_coef, switch_coef):\n        self.qual = qual_coef\n        self.buf = buf_coef\n        self.switch = switch_coef\n        self.rebuffers = []\n        self.switches = []\n        self.chunk_info = []\n    def log_bitrate_choice(self, time, chunknum, chunk):\n        self.chunk_info.append({\"number\" : chunknum,",
        "detail": "HW2.Classes.Scorecard",
        "documentation": {}
    },
    {
        "label": "SimBuffer",
        "kind": 6,
        "importPath": "HW2.Classes.SimBuffer",
        "description": "HW2.Classes.SimBuffer",
        "peekOfCode": "class SimBuffer:\n    def __init__(self, bufsize):\n        self.size = bufsize\n        self.chunks = [] #each chunk object is a tuple (size, chunk_time)\n        self.time = 0\n        self.cur_size = 0\n        self.mid_chunk_time = 0\n    def get_student_params(self):\n        params = {}\n        params[\"size\"] = self.size",
        "detail": "HW2.Classes.SimBuffer",
        "documentation": {}
    },
    {
        "label": "send_req_json",
        "kind": 2,
        "importPath": "HW2.Classes.simulator_comm",
        "description": "HW2.Classes.simulator_comm",
        "peekOfCode": "def send_req_json(m_band, prev_throughput, buf_occ, av_bitrates, current_time, chunk_arg, rebuff_time, pref_bitrate ):\n    #pack message\n    req = json.dumps({\"Measured Bandwidth\" : m_band,\n                     \"Previous Throughput\" : prev_throughput,\n                     \"Buffer Occupancy\" : buf_occ,\n                     \"Available Bitrates\" : av_bitrates,\n                     \"Video Time\" : current_time,\n                     \"Chunk\" : chunk_arg,\n                     \"Rebuffering Time\" : rebuff_time,\n                     \"Preferred Bitrate\" : pref_bitrate,",
        "detail": "HW2.Classes.simulator_comm",
        "documentation": {}
    },
    {
        "label": "send_exit",
        "kind": 2,
        "importPath": "HW2.Classes.simulator_comm",
        "description": "HW2.Classes.simulator_comm",
        "peekOfCode": "def send_exit():\n    req = json.dumps({\"exit\" : 1})\n    req += '\\n'\n    s.sendall(req.encode())\nif __name__ == \"__main__\":\n    pass",
        "detail": "HW2.Classes.simulator_comm",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "HW2.Classes.simulator_comm",
        "description": "HW2.Classes.simulator_comm",
        "peekOfCode": "s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\ns.connect(('localhost', 6000))\ndef send_req_json(m_band, prev_throughput, buf_occ, av_bitrates, current_time, chunk_arg, rebuff_time, pref_bitrate ):\n    #pack message\n    req = json.dumps({\"Measured Bandwidth\" : m_band,\n                     \"Previous Throughput\" : prev_throughput,\n                     \"Buffer Occupancy\" : buf_occ,\n                     \"Available Bitrates\" : av_bitrates,\n                     \"Video Time\" : current_time,",
        "detail": "HW2.Classes.simulator_comm",
        "documentation": {}
    },
    {
        "label": "run_student_code",
        "kind": 2,
        "importPath": "HW2.grader",
        "description": "HW2.grader",
        "peekOfCode": "def run_student_code():\n    subprocess.run(['python', 'studentComm.py'])\n    return\nif __name__ == \"__main__\":\n    #check for verbosity\n    verboseflag = \"\"\n    if \"-v\" in sys.argv or \"--verbose\" in sys.argv:\n        verboseflag = \"-v\"\n    switch_ratio = 1\n    buffer_ratio = 1",
        "detail": "HW2.grader",
        "documentation": {}
    },
    {
        "label": "CHUNK_TIME",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "CHUNK_TIME = 2\nNUM_OF_CHUNKS = 30\nlow_BR = 500000\nmed_BR = 1000000\nhigh_BR = 5000000\nBuffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "NUM_OF_CHUNKS",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "NUM_OF_CHUNKS = 30\nlow_BR = 500000\nmed_BR = 1000000\nhigh_BR = 5000000\nBuffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "low_BR",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "low_BR = 500000\nmed_BR = 1000000\nhigh_BR = 5000000\nBuffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "med_BR",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "med_BR = 1000000\nhigh_BR = 5000000\nBuffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "high_BR",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "high_BR = 5000000\nBuffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "Buffer_Size",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "Buffer_Size = 40000000\n# generate random chunk sizes for the manifest, WIP\nlow = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "low",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "low = np.random.normal(low_BR / 8, 5000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nmed = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "med",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "med = np.random.normal(med_BR / 8, 10000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\nhigh = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "high",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "high = np.random.normal(high_BR / 8, 50000 / 8, NUM_OF_CHUNKS) * CHUNK_TIME\ndata = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data = {}\ndata['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Video_Time']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Video_Time'] = NUM_OF_CHUNKS * CHUNK_TIME\ndata['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Chunk_Count']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Chunk_Count'] = NUM_OF_CHUNKS\ndata['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),\n        int(high[i])",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Chunk_Time']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Chunk_Time'] = CHUNK_TIME\ndata['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),\n        int(high[i])\n    ]",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Buffer_Size']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Buffer_Size'] = Buffer_Size\ndata['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),\n        int(high[i])\n    ]\nprint(json.dumps(data, indent=4))",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Available_Bitrates']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Available_Bitrates'] = [low_BR, med_BR, high_BR]\ndata['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),\n        int(high[i])\n    ]\nprint(json.dumps(data, indent=4))",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "data['Chunks']",
        "kind": 5,
        "importPath": "HW2.rand_sizes",
        "description": "HW2.rand_sizes",
        "peekOfCode": "data['Chunks'] = {}\nfor i in range(30):\n    data['Chunks'][str(i)] = [\n        int(low[i]),\n        int(med[i]),\n        int(high[i])\n    ]\nprint(json.dumps(data, indent=4))",
        "detail": "HW2.rand_sizes",
        "documentation": {}
    },
    {
        "label": "loadtrace",
        "kind": 2,
        "importPath": "HW2.simulator",
        "description": "HW2.simulator",
        "peekOfCode": "def loadtrace(tracefile):\n    with open(tracefile, 'r',encoding='utf-8') as infile:\n        lines = infile.readlines()\n    tracelog = []\n    for line in lines:\n        splitline = line.split(' ')\n        if len(splitline) > 1:\n            try:\n                tracelog.append((float(splitline[0]), float(splitline[1])))\n            except ValueError as e:",
        "detail": "HW2.simulator",
        "documentation": {}
    },
    {
        "label": "loadmanifest",
        "kind": 2,
        "importPath": "HW2.simulator",
        "description": "HW2.simulator",
        "peekOfCode": "def loadmanifest(manifestfile):\n    with open(manifestfile, 'r', encoding='utf-8') as infile:\n        lines = infile.read()\n    manifest = json.loads(lines)\n    return manifest\ndef prep_bitrates(available_rates, chunk):\n    rates = dict(map(lambda x, y: (x, y), available_rates, chunk))\n    return rates\ndef prep_chunk(chunks_rem, manifest, chunk_num):\n    params = {  \"left\" : chunks_remaining,",
        "detail": "HW2.simulator",
        "documentation": {}
    },
    {
        "label": "prep_bitrates",
        "kind": 2,
        "importPath": "HW2.simulator",
        "description": "HW2.simulator",
        "peekOfCode": "def prep_bitrates(available_rates, chunk):\n    rates = dict(map(lambda x, y: (x, y), available_rates, chunk))\n    return rates\ndef prep_chunk(chunks_rem, manifest, chunk_num):\n    params = {  \"left\" : chunks_remaining,\n                \"time\" : manifest[\"Chunk_Time\"],\n                \"current\" : chunk_num\n                }\n    return params\nif __name__ == \"__main__\":",
        "detail": "HW2.simulator",
        "documentation": {}
    },
    {
        "label": "prep_chunk",
        "kind": 2,
        "importPath": "HW2.simulator",
        "description": "HW2.simulator",
        "peekOfCode": "def prep_chunk(chunks_rem, manifest, chunk_num):\n    params = {  \"left\" : chunks_remaining,\n                \"time\" : manifest[\"Chunk_Time\"],\n                \"current\" : chunk_num\n                }\n    return params\nif __name__ == \"__main__\":\n    #check arguments for relevant flags\n    if \"-v\" in sys.argv or \"--verbose\" in sys.argv:\n        verbose = True",
        "detail": "HW2.simulator",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "HW2.simulator",
        "description": "HW2.simulator",
        "peekOfCode": "verbose = False\ndef loadtrace(tracefile):\n    with open(tracefile, 'r',encoding='utf-8') as infile:\n        lines = infile.readlines()\n    tracelog = []\n    for line in lines:\n        splitline = line.split(' ')\n        if len(splitline) > 1:\n            try:\n                tracelog.append((float(splitline[0]), float(splitline[1])))",
        "detail": "HW2.simulator",
        "documentation": {}
    },
    {
        "label": "recv_commands",
        "kind": 2,
        "importPath": "HW2.studentComm",
        "description": "HW2.studentComm",
        "peekOfCode": "def recv_commands():\n    message = \"\"\n    while(1):\n        messagepart = clientsocket.recv(2048).decode()\n        message += messagepart\n        if message[-1] == '\\n':\n            jsonargs = json.loads(messagepart)\n            message = \"\"\n            if(jsonargs[\"exit\"] != 0):\n                return",
        "detail": "HW2.studentComm",
        "documentation": {}
    },
    {
        "label": "ss",
        "kind": 5,
        "importPath": "HW2.studentComm",
        "description": "HW2.studentComm",
        "peekOfCode": "ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nss.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nss.bind(('localhost', 6000))\nss.listen(10)\nprint('Waiting for simulator')\n(clientsocket, address) = ss.accept()\ndef recv_commands():\n    message = \"\"\n    while(1):\n        messagepart = clientsocket.recv(2048).decode()",
        "detail": "HW2.studentComm",
        "documentation": {}
    },
    {
        "label": "student_entrypoint",
        "kind": 2,
        "importPath": "HW2.studentcodeExample",
        "description": "HW2.studentcodeExample",
        "peekOfCode": "def student_entrypoint(Measured_Bandwidth, Previous_Throughput, Buffer_Occupancy, Available_Bitrates, Video_Time, Chunk, Rebuffering_Time, Preferred_Bitrate ):\n    #student can do whatever they want from here going forward\n    global bitrate\n    R_i = list(Available_Bitrates.items())\n    R_i.sort(key=lambda tup: tup[1] , reverse=True)\n    bitrate = bufferbased(rate_prev=bitrate, buf_now= Buffer_Occupancy, r=Chunk['time']+1,R_i= R_i ) \n    return bitrate\n#helper function, to find the corresponding size of previous bitrate\ndef match(value, list_of_list): \n    for e in list_of_list:",
        "detail": "HW2.studentcodeExample",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 2,
        "importPath": "HW2.studentcodeExample",
        "description": "HW2.studentcodeExample",
        "peekOfCode": "def match(value, list_of_list): \n    for e in list_of_list:\n        if value == e[1]:\n            return e\n#helper function, to find the corresponding size of previous bitrate\n#if there's was no previous assume that it was the highest possible value\ndef prevmatch(value, list_of_list): \n    for e in list_of_list:\n        if value == e[1]:\n            return e",
        "detail": "HW2.studentcodeExample",
        "documentation": {}
    },
    {
        "label": "prevmatch",
        "kind": 2,
        "importPath": "HW2.studentcodeExample",
        "description": "HW2.studentcodeExample",
        "peekOfCode": "def prevmatch(value, list_of_list): \n    for e in list_of_list:\n        if value == e[1]:\n            return e\n    value = max(i[1] for i in list_of_list)\n    for e in list_of_list:\n        if value == e[1]:\n            return e\ndef bufferbased(rate_prev, buf_now, r, R_i , cu = 126):\n    '''",
        "detail": "HW2.studentcodeExample",
        "documentation": {}
    },
    {
        "label": "bufferbased",
        "kind": 2,
        "importPath": "HW2.studentcodeExample",
        "description": "HW2.studentcodeExample",
        "peekOfCode": "def bufferbased(rate_prev, buf_now, r, R_i , cu = 126):\n    '''\n    Input: \n    rate_prev: The previously used video rate\n    Buf_now: The current buffer occupancy \n    r: The size of reservoir  //At least greater than Chunk Time\n    cu: The size of cushion //between 90 to 216, paper used 126\n    R_i: Array of bitrates of videos, key will be bitrate, and value will be the byte size of the chunk\n    Output: \n    Rate_next: The next video rate",
        "detail": "HW2.studentcodeExample",
        "documentation": {}
    },
    {
        "label": "bitrate",
        "kind": 5,
        "importPath": "HW2.studentcodeExample",
        "description": "HW2.studentcodeExample",
        "peekOfCode": "bitrate = 0 #used to save previous bitrate\ndef student_entrypoint(Measured_Bandwidth, Previous_Throughput, Buffer_Occupancy, Available_Bitrates, Video_Time, Chunk, Rebuffering_Time, Preferred_Bitrate ):\n    #student can do whatever they want from here going forward\n    global bitrate\n    R_i = list(Available_Bitrates.items())\n    R_i.sort(key=lambda tup: tup[1] , reverse=True)\n    bitrate = bufferbased(rate_prev=bitrate, buf_now= Buffer_Occupancy, r=Chunk['time']+1,R_i= R_i ) \n    return bitrate\n#helper function, to find the corresponding size of previous bitrate\ndef match(value, list_of_list): ",
        "detail": "HW2.studentcodeExample",
        "documentation": {}
    },
    {
        "label": "handle_bola",
        "kind": 2,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "def handle_bola(bola_state, buffer_level, bandwidth):\n    quality_index = None\n    max_score = -float(\"inf\")\n    for i, bitrate in enumerate(bola_state[\"bitrates\"]):\n        # maximize target = (V * (υm - 1 + γp) - Q) / Sm. Fig. 6, line 6 in paper\n        score = (\n            bola_state[\"Vp\"] * (bola_state[\"utilities\"][i] - 1 + bola_state[\"gp\"])\n            - buffer_level\n        ) / bitrate\n        if score > max_score:",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "initialize_bola_state",
        "kind": 2,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "def initialize_bola_state(bitrates):\n    # calculate logarithmic utility values\n    utilities = [math.log(b) for b in bitrates]\n    utilities = [u - utilities[0] + 1 for u in utilities]\n    highest_utility_index = utilities.index(max(utilities))\n    buffer_time = max(\n        BUFFER_TIME_DEFAULT,\n        MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * len(bitrates),\n    )\n    # If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "student_entrypoint",
        "kind": 2,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "def student_entrypoint(\n    Measured_Bandwidth,\n    Previous_Throughput,\n    Buffer_Occupancy,\n    Available_Bitrates,\n    Video_Time,\n    Chunk,\n    Rebuffering_Time,\n    Preferred_Bitrate,\n):",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "BUFFER_TIME_DEFAULT",
        "kind": 5,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "BUFFER_TIME_DEFAULT = 12  # Default buffer time, from https://github.com/Dash-Industry-Forum/dash.js/blob/development/src/streaming/models/MediaPlayerModel.js#L35\nMINIMUM_BUFFER_S = 10  # p in paper\nMINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2\ndef handle_bola(bola_state, buffer_level, bandwidth):\n    quality_index = None\n    max_score = -float(\"inf\")\n    for i, bitrate in enumerate(bola_state[\"bitrates\"]):\n        # maximize target = (V * (υm - 1 + γp) - Q) / Sm. Fig. 6, line 6 in paper\n        score = (\n            bola_state[\"Vp\"] * (bola_state[\"utilities\"][i] - 1 + bola_state[\"gp\"])",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "MINIMUM_BUFFER_S",
        "kind": 5,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "MINIMUM_BUFFER_S = 10  # p in paper\nMINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2\ndef handle_bola(bola_state, buffer_level, bandwidth):\n    quality_index = None\n    max_score = -float(\"inf\")\n    for i, bitrate in enumerate(bola_state[\"bitrates\"]):\n        # maximize target = (V * (υm - 1 + γp) - Q) / Sm. Fig. 6, line 6 in paper\n        score = (\n            bola_state[\"Vp\"] * (bola_state[\"utilities\"][i] - 1 + bola_state[\"gp\"])\n            - buffer_level",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    },
    {
        "label": "MINIMUM_BUFFER_PER_BITRATE_LEVEL_S",
        "kind": 5,
        "importPath": "HW2.studentcode_122090513",
        "description": "HW2.studentcode_122090513",
        "peekOfCode": "MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2\ndef handle_bola(bola_state, buffer_level, bandwidth):\n    quality_index = None\n    max_score = -float(\"inf\")\n    for i, bitrate in enumerate(bola_state[\"bitrates\"]):\n        # maximize target = (V * (υm - 1 + γp) - Q) / Sm. Fig. 6, line 6 in paper\n        score = (\n            bola_state[\"Vp\"] * (bola_state[\"utilities\"][i] - 1 + bola_state[\"gp\"])\n            - buffer_level\n        ) / bitrate",
        "detail": "HW2.studentcode_122090513",
        "documentation": {}
    }
]